<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sean&#39;s Blog</title>
  
  <subtitle>闷声发大财</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://seanxuu.github.io/"/>
  <updated>2021-07-04T07:05:09.000Z</updated>
  <id>https://seanxuu.github.io/</id>
  
  <author>
    <name>Sean Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>boring</title>
    <link href="https://seanxuu.github.io/archives/4104c504.html"/>
    <id>https://seanxuu.github.io/archives/4104c504.html</id>
    <published>2021-07-04T07:05:09.000Z</published>
    <updated>2021-07-04T07:05:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天真的什么事情都不想做，哎！！！！</p><p>在现在的公司干的真不爽，每天做事一点成就感都没有。想做点技术革新，又没有人力物力和领导的支持，最后只能摆烂，写一些垃圾代码。我很想改变，却又没有什么动力。我好苦恼。</p><p>然后很讨厌的一个项目经理又被领导提拔了，事实上她的管理能力一塌糊涂，干个项目都是我们这帮打工人给她擦屁股。真的难受。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天真的什么事情都不想做，哎！！！！&lt;/p&gt;
&lt;p&gt;在现在的公司干的真不爽，每天做事一点成就感都没有。想做点技术革新，又没有人力物力和领导的支持，最后只能摆烂，写一些垃圾代码。我很想改变，却又没有什么动力。我好苦恼。&lt;/p&gt;
&lt;p&gt;然后很讨厌的一个项目经理又被领导提拔了，事
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>入职一年感想</title>
    <link href="https://seanxuu.github.io/archives/f969517f.html"/>
    <id>https://seanxuu.github.io/archives/f969517f.html</id>
    <published>2020-08-23T02:51:58.000Z</published>
    <updated>2020-08-23T02:51:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，都已经工作一年了。并不觉得工作的有多快乐，刚开始的半年还会有成就感，自己做的东西会有很多人使用。但是现在，真的有些累了。每天上班做的最多的事情就是讨论需求，明确需求。到了快下班了，才腾出手来有精力开发。这种状态很不好，我很不喜欢。虽然对银行的业务流程、技术架构有了更多的认识，但是在这个庞大的体系里，我仿佛并没有找到自己的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉，都已经工作一年了。并不觉得工作的有多快乐，刚开始的半年还会有成就感，自己做的东西会有很多人使用。但是现在，真的有些累了。每天上班做的最多的事情就是讨论需求，明确需求。到了快下班了，才腾出手来有精力开发。这种状态很不好，我很不喜欢。虽然对银行的业务流程、技术架构有了
      
    
    </summary>
    
      <category term="随想" scheme="https://seanxuu.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="工作" scheme="https://seanxuu.github.io/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-3. Longest Substring Without Repeating Characters</title>
    <link href="https://seanxuu.github.io/archives/c4d05eca.html"/>
    <id>https://seanxuu.github.io/archives/c4d05eca.html</id>
    <published>2019-05-13T04:18:58.000Z</published>
    <updated>2019-05-13T04:18:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/</a></strong></p><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p>题目大意：</p><p>求出没有重复字母的最长字串的长度。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">1</span>, start = <span class="number">0</span>, end = <span class="number">1</span>, len = <span class="number">1</span>;</span><br><span class="line">String curStr;</span><br><span class="line"><span class="keyword">while</span> (end &lt; s.length()) &#123;</span><br><span class="line">curStr = s.substring(start, end);</span><br><span class="line"><span class="keyword">if</span> (curStr.contains(String.valueOf(s.charAt(end)))) &#123;</span><br><span class="line">start = s.indexOf(s.charAt(end), start) + <span class="number">1</span>;</span><br><span class="line">end++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">len = end - start + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">maxLen = len;</span><br><span class="line">&#125;</span><br><span class="line">end++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://le
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-2. Add Two Numbers</title>
    <link href="https://seanxuu.github.io/archives/32c9af6f.html"/>
    <id>https://seanxuu.github.io/archives/32c9af6f.html</id>
    <published>2019-05-13T01:33:35.000Z</published>
    <updated>2019-05-13T01:33:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode.com/problems/add-two-numbers/</a></strong></p><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>题目大意：</p><p>有两个链表，它们表示逆序的两个非负数。计算出两个数的和之后，同样逆序输出作为一个链表。</p><p>需要注意一点：<strong>有进位</strong></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span> || l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode result = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> value2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            value2 = (l1.val + l2.val + value1) % <span class="number">10</span>;</span><br><span class="line">            value1 = (l1.val + l2.val + value1) / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            temp.next = <span class="keyword">new</span> ListNode(value2);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                l1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                l2 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value1 != <span class="number">0</span>) &#123;</span><br><span class="line">            temp.next = <span class="keyword">new</span> ListNode(value1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode.com/problems/add-two-num
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>推荐一个IT电子书网站</title>
    <link href="https://seanxuu.github.io/archives/3ebe3fa9.html"/>
    <id>https://seanxuu.github.io/archives/3ebe3fa9.html</id>
    <published>2019-05-12T13:11:30.000Z</published>
    <updated>2019-05-12T13:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在网上冲浪的时候，无意间发现一个IT方面电子书的下载网站<a href="https://itbook.download/" target="_blank" rel="noopener">https://itbook.download/</a>，然而当时没放在心上。直到最近，做毕业设计的时候要用到神经网络方面的书籍，图书馆又基本借不到，所以就想起来这个网站了。</p><p>虽然下载盗版书籍让我有些惭愧，但是应对不时之需还是有点用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在网上冲浪的时候，无意间发现一个IT方面电子书的下载网站&lt;a href=&quot;https://itbook.download/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://itbook.download/&lt;/a&gt;，然而当时没放在心上。直到
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>消息队列是一个什么东西？</title>
    <link href="https://seanxuu.github.io/archives/d47314cf.html"/>
    <id>https://seanxuu.github.io/archives/d47314cf.html</id>
    <published>2019-04-14T01:53:59.000Z</published>
    <updated>2019-04-14T01:53:59.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://seanxuu.github.io/archives/6a343b7f.html"/>
    <id>https://seanxuu.github.io/archives/6a343b7f.html</id>
    <published>2019-04-14T01:52:10.000Z</published>
    <updated>2019-04-14T01:52:10.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中的一些易混淆点总结</title>
    <link href="https://seanxuu.github.io/archives/1682a1e.html"/>
    <id>https://seanxuu.github.io/archives/1682a1e.html</id>
    <published>2019-04-14T01:48:43.000Z</published>
    <updated>2019-04-14T01:48:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abstrcat"><a href="#abstrcat" class="headerlink" title="abstrcat"></a>abstrcat</h1><h1 id="sleep-与wait"><a href="#sleep-与wait" class="headerlink" title="sleep()与wait()"></a>sleep()与wait()</h1><h1 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals()"></a>== 与 equals()</h1><h1 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h1><h1 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h1><h1 id="try-…-catch-…-finally-…"><a href="#try-…-catch-…-finally-…" class="headerlink" title="try{…}catch{…}finally{…}"></a>try{…}catch{…}finally{…}</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;abstrcat&quot;&gt;&lt;a href=&quot;#abstrcat&quot; class=&quot;headerlink&quot; title=&quot;abstrcat&quot;&gt;&lt;/a&gt;abstrcat&lt;/h1&gt;&lt;h1 id=&quot;sleep-与wait&quot;&gt;&lt;a href=&quot;#sleep-与wait&quot; class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试中常用排序算法总结</title>
    <link href="https://seanxuu.github.io/archives/cc73e49b.html"/>
    <id>https://seanxuu.github.io/archives/cc73e49b.html</id>
    <published>2019-04-11T08:28:33.000Z</published>
    <updated>2019-04-11T08:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h1 id="二分排序"><a href="#二分排序" class="headerlink" title="二分排序"></a>二分排序</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h2><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><h2 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h2><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h2><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指offer题解</title>
    <link href="https://seanxuu.github.io/archives/863370b6.html"/>
    <id>https://seanxuu.github.io/archives/863370b6.html</id>
    <published>2019-04-07T06:10:32.000Z</published>
    <updated>2019-04-07T06:10:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="面试题3：数组中重复的数字"><a href="#面试题3：数组中重复的数字" class="headerlink" title="面试题3：数组中重复的数字"></a>面试题3：数组中重复的数字</h3><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><p>思路：构造一个辅助数组help，将原数组A中的每个数对应到help数组的下标，第一次对应以后，将help数组中的对应元素+1。如果有重复数字的话，很明显help数组中的对应元素一定大于1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题3：数组中重复的数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] help = <span class="keyword">new</span> <span class="keyword">int</span> [length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(help[numbers[i]]==<span class="number">0</span>)&#123;</span><br><span class="line">                help[numbers[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;duplication[<span class="number">0</span>]=numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题4：二维数组中的查找"><a href="#面试题4：二维数组中的查找" class="headerlink" title="面试题4：二维数组中的查找"></a>面试题4：二维数组中的查找</h3><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>思路：从左下角开始，比target小的数一定在左下角的上方，比target大的数一定在左下角的右方。所以以左下角为标准，向上挪一步或者向左挪一步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试题4：二维数组中的查找</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row =array.length;</span><br><span class="line">        <span class="keyword">int</span> column =array[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i=row-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;column)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;array[i][j])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[i][j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题11-旋转数组的最小数字"><a href="#面试题11-旋转数组的最小数字" class="headerlink" title="面试题11. 旋转数组的最小数字"></a>面试题11. 旋转数组的最小数字</h3><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><p>思路：分三种情况，如下，</p><p>1.数组为空 ，返回0  </p><p>2.部分旋转，例如由（1,2,3,4,5）旋转为（3,4,5,1,2），此时只需要遍历数组，找到当前数比前面的数小的数即可。   </p><p>3.完全旋转，例如由（1,2,3,4,5）旋转为（1,2,3,4,5），此时第一个数最小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i &lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i]&gt;array[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> array[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>]&lt;array[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题21：调整数组顺序使得奇数位于偶数前面"><a href="#面试题21：调整数组顺序使得奇数位于偶数前面" class="headerlink" title="面试题21：调整数组顺序使得奇数位于偶数前面"></a>面试题21：调整数组顺序使得奇数位于偶数前面</h3><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><p>思路：类似于冒泡排序，前偶后奇就两两交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; array[j + <span class="number">1</span>] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题39：数组中出现超过一半的数字"><a href="#面试题39：数组中出现超过一半的数字" class="headerlink" title="面试题39：数组中出现超过一半的数字"></a>面试题39：数组中出现超过一半的数字</h3><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></blockquote><p>思路：利用快排进行排序，数组中间那个数一定是要求的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为用到了sort，时间复杂度O(NlogN)，并非最优</span></span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>); <span class="comment">// 排序，取数组中间那个数</span></span><br><span class="line">        <span class="keyword">int</span> middle = array[array.length / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == middle)</span><br><span class="line">                ++count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (count &gt; array.length / <span class="number">2</span>) ? middle : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题40：最小的k个数"><a href="#面试题40：最小的k个数" class="headerlink" title="面试题40：最小的k个数"></a>面试题40：最小的k个数</h3><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><p>思路：我觉得这一题依然可以用快排，时间复杂度也只有O(NlogN)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || k &gt; input.length || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Arrays.sort(input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题42：连续子数组的最大和"><a href="#面试题42：连续子数组的最大和" class="headerlink" title="面试题42：连续子数组的最大和"></a>面试题42：连续子数组的最大和</h3><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><p>思路：维护一个temp，将之前累加的和与当前遍历到的值（result）进行对比，如果累加和小于0，则设temp为0，再与result对比。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array== <span class="keyword">null</span>||array.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">int</span> temp = array[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">int</span> result = array[<span class="number">0</span>] ;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt; array.length;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)&#123;</span><br><span class="line">               temp = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           temp+=array[i];</span><br><span class="line">           <span class="keyword">if</span>(temp&gt;=result)&#123;</span><br><span class="line">               result = temp;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题45：把数组排成最小的数"><a href="#面试题45：把数组排成最小的数" class="headerlink" title="面试题45：把数组排成最小的数"></a>面试题45：把数组排成最小的数</h3><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题51：数组中的逆序对"><a href="#面试题51：数组中的逆序对" class="headerlink" title="面试题51：数组中的逆序对"></a>面试题51：数组中的逆序对</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题53：数字在排序数组中出现的次数"><a href="#面试题53：数字在排序数组中出现的次数" class="headerlink" title="面试题53：数字在排序数组中出现的次数"></a>面试题53：数字在排序数组中出现的次数</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题56：数组中只出现一次的二个数字（56-1）"><a href="#面试题56：数组中只出现一次的二个数字（56-1）" class="headerlink" title="面试题56：数组中只出现一次的二个数字（56_1）"></a>面试题56：数组中只出现一次的二个数字（56_1）</h3><h3 id="面试题56-2-数组中只有一个数出现一次，其他数字出现三次，求出这个出现一次的数字"><a href="#面试题56-2-数组中只有一个数出现一次，其他数字出现三次，求出这个出现一次的数字" class="headerlink" title="面试题56_2:数组中只有一个数出现一次，其他数字出现三次，求出这个出现一次的数字"></a>面试题56_2:数组中只有一个数出现一次，其他数字出现三次，求出这个出现一次的数字</h3><h3 id="面试题66：构建乘积数组"><a href="#面试题66：构建乘积数组" class="headerlink" title="面试题66：构建乘积数组"></a>面试题66：构建乘积数组</h3><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="面试题6：从尾到头打印链表"><a href="#面试题6：从尾到头打印链表" class="headerlink" title="面试题6：从尾到头打印链表"></a>面试题6：从尾到头打印链表</h3><blockquote><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p></blockquote><p>思路：利用一个辅助栈实现。将链表中的值依次弹出加入辅助栈中。由于栈的后进先出的特点，直接依次弹出所有值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">Stack&lt;Integer&gt; stack =<span class="keyword">new</span> Stack();</span><br><span class="line"><span class="keyword">while</span>(listNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">stack.add(listNode.val);</span><br><span class="line">listNode = listNode.next;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;Integer&gt;integers=<span class="keyword">new</span> ArrayList&lt;&gt;(stack.capacity());</span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">integers.add(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> integers;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题18-1：在O-1-时间删除链表结点"><a href="#面试题18-1：在O-1-时间删除链表结点" class="headerlink" title="面试题18_1：在O(1)时间删除链表结点"></a>面试题18_1：在O(1)时间删除链表结点</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题18-2：删除链表中重复的结点"><a href="#面试题18-2：删除链表中重复的结点" class="headerlink" title="面试题18_2：删除链表中重复的结点"></a>面试题18_2：删除链表中重复的结点</h3><h3 id="面试题22：链表中倒数第k个结点"><a href="#面试题22：链表中倒数第k个结点" class="headerlink" title="面试题22：链表中倒数第k个结点"></a>面试题22：链表中倒数第k个结点</h3><h3 id="面试题23：链表中环的入口结点"><a href="#面试题23：链表中环的入口结点" class="headerlink" title="面试题23：链表中环的入口结点"></a>面试题23：链表中环的入口结点</h3><h3 id="面试题24：反转链表"><a href="#面试题24：反转链表" class="headerlink" title="面试题24：反转链表"></a>面试题24：反转链表</h3><h3 id="面试题25：合并两个排序的链表"><a href="#面试题25：合并两个排序的链表" class="headerlink" title="面试题25：合并两个排序的链表"></a>面试题25：合并两个排序的链表</h3><h3 id="面试题35：复杂链表的复制"><a href="#面试题35：复杂链表的复制" class="headerlink" title="面试题35：复杂链表的复制"></a>面试题35：复杂链表的复制</h3><h3 id="面试题52：两个链表的第一个公共结点"><a href="#面试题52：两个链表的第一个公共结点" class="headerlink" title="面试题52：两个链表的第一个公共结点"></a>面试题52：两个链表的第一个公共结点</h3><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="面试题4：替换空格"><a href="#面试题4：替换空格" class="headerlink" title="面试题4：替换空格"></a>面试题4：替换空格</h3><h3 id="面试题12：打印1到最大的n位数"><a href="#面试题12：打印1到最大的n位数" class="headerlink" title="面试题12：打印1到最大的n位数"></a>面试题12：打印1到最大的n位数</h3><h3 id="面试题20：表示数值的字符串"><a href="#面试题20：表示数值的字符串" class="headerlink" title="面试题20：表示数值的字符串"></a>面试题20：表示数值的字符串</h3><h3 id="面试题28：字符串的排列"><a href="#面试题28：字符串的排列" class="headerlink" title="面试题28：字符串的排列"></a>面试题28：字符串的排列</h3><h3 id="面试题43：从1到n整数中1出现的次数"><a href="#面试题43：从1到n整数中1出现的次数" class="headerlink" title="面试题43：从1到n整数中1出现的次数"></a>面试题43：从1到n整数中1出现的次数</h3><h3 id="面试题50：第一个只出现1次的字符"><a href="#面试题50：第一个只出现1次的字符" class="headerlink" title="面试题50：第一个只出现1次的字符"></a>面试题50：第一个只出现1次的字符</h3><h3 id="面试题50-2：字符流中第一个不重复的字符"><a href="#面试题50-2：字符流中第一个不重复的字符" class="headerlink" title="面试题50_2：字符流中第一个不重复的字符"></a>面试题50_2：字符流中第一个不重复的字符</h3><h3 id="面试题58：反转单词顺序以及左旋转字符串"><a href="#面试题58：反转单词顺序以及左旋转字符串" class="headerlink" title="面试题58：反转单词顺序以及左旋转字符串"></a>面试题58：反转单词顺序以及左旋转字符串</h3><h3 id="面试题67：把字符串转换成整数"><a href="#面试题67：把字符串转换成整数" class="headerlink" title="面试题67：把字符串转换成整数"></a>面试题67：把字符串转换成整数</h3><h3 id="面试题53：正则表达式匹配"><a href="#面试题53：正则表达式匹配" class="headerlink" title="面试题53：正则表达式匹配"></a>面试题53：正则表达式匹配</h3><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h3 id="面试题7：用两个栈实现队列"><a href="#面试题7：用两个栈实现队列" class="headerlink" title="面试题7：用两个栈实现队列"></a>面试题7：用两个栈实现队列</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题21：包含min函数的栈"><a href="#面试题21：包含min函数的栈" class="headerlink" title="面试题21：包含min函数的栈"></a>面试题21：包含min函数的栈</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题22：栈的压入、弹出序列"><a href="#面试题22：栈的压入、弹出序列" class="headerlink" title="面试题22：栈的压入、弹出序列"></a>面试题22：栈的压入、弹出序列</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树的算法题的一个重要思想就是<strong>遍历</strong>。</p><h3 id="面试题6：重建二叉树"><a href="#面试题6：重建二叉树" class="headerlink" title="面试题6：重建二叉树"></a>面试题6：重建二叉树</h3><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><p>思路：前序遍历序列的第一个数字是整棵树的根节点，中序遍历序列以根节点为分界点将整个序列分为左子树和右子树两个部分（左边就是左子树，右边就是右子树）。所以只要递归求出结果即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">          TreeNode root=reConstructBTree(pre,<span class="number">0</span>,pre.length-<span class="number">1</span>,in,<span class="number">0</span>,in.length-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> startPre,<span class="keyword">int</span> endPre,<span class="keyword">int</span> [] in,<span class="keyword">int</span> startIn,<span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">            <span class="keyword">if</span>(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            TreeNode root=<span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)</span><br><span class="line">                <span class="keyword">if</span>(in[i]==pre[startPre])&#123;</span><br><span class="line">                    root.left=reConstructBTree(pre,startPre+<span class="number">1</span>,startPre+i-startIn,in,startIn,i-<span class="number">1</span>);</span><br><span class="line">                    root.right=reConstructBTree(pre,i-startIn+startPre+<span class="number">1</span>,endPre,in,i+<span class="number">1</span>,endIn);</span><br><span class="line">                &#125;</span><br><span class="line">                       </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题18：树的子结构"><a href="#面试题18：树的子结构" class="headerlink" title="面试题18：树的子结构"></a>面试题18：树的子结构</h3><blockquote><p>​    输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></blockquote><p>思路：主要分为两部分。第一部分，判断各种特殊情况：1.树是否为空 2.某一棵树的根节点是否在另一棵树里存在，并且是其子树的根节点。第二部分，遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当Tree1和Tree2都不为空的时候，才进行比较。否则直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (root2 != <span class="keyword">null</span> &amp;&amp; root1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果找到了对应Tree2的根节点的点</span></span><br><span class="line">            <span class="keyword">if</span>(root1.val == root2.val)&#123;</span><br><span class="line">                <span class="comment">//以这个根节点为为起点判断是否包含Tree2</span></span><br><span class="line">                result = doesTree1HaveTree2(root1,root2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果找不到，那么就再去root的左儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                result = HasSubtree(root1.left,root2);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果还找不到，那么就再去root的右儿子当作起点，去判断时候包含Tree2</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                result = HasSubtree(root1.right,root2);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doesTree1HaveTree2</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果Tree2已经遍历完了都能对应的上，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (node2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果其中有一个点没有对应上，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (node1.val != node2.val) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//如果根节点对应的上，那么就分别去子节点里面匹配</span></span><br><span class="line">        <span class="keyword">return</span> doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="面试题19：二叉树镜像"><a href="#面试题19：二叉树镜像" class="headerlink" title="面试题19：二叉树镜像"></a>面试题19：二叉树镜像</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题23：从上往下打印二叉树"><a href="#面试题23：从上往下打印二叉树" class="headerlink" title="面试题23：从上往下打印二叉树"></a>面试题23：从上往下打印二叉树</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题24：二叉搜索树的后序遍历"><a href="#面试题24：二叉搜索树的后序遍历" class="headerlink" title="面试题24：二叉搜索树的后序遍历"></a>面试题24：二叉搜索树的后序遍历</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题25：二叉树中和为某一值的路径"><a href="#面试题25：二叉树中和为某一值的路径" class="headerlink" title="面试题25：二叉树中和为某一值的路径"></a>面试题25：二叉树中和为某一值的路径</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题27：二叉搜索树与双向链表"><a href="#面试题27：二叉搜索树与双向链表" class="headerlink" title="面试题27：二叉搜索树与双向链表"></a>面试题27：二叉搜索树与双向链表</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题39：二叉树的深度"><a href="#面试题39：二叉树的深度" class="headerlink" title="面试题39：二叉树的深度"></a>面试题39：二叉树的深度</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题50：树中两个节点的最低公共祖先"><a href="#面试题50：树中两个节点的最低公共祖先" class="headerlink" title="面试题50：树中两个节点的最低公共祖先"></a>面试题50：树中两个节点的最低公共祖先</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题58：二叉树的下一个节点"><a href="#面试题58：二叉树的下一个节点" class="headerlink" title="面试题58：二叉树的下一个节点"></a>面试题58：二叉树的下一个节点</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题59：对称的二叉树"><a href="#面试题59：对称的二叉树" class="headerlink" title="面试题59：对称的二叉树"></a>面试题59：对称的二叉树</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题60：把二叉树打印成多行"><a href="#面试题60：把二叉树打印成多行" class="headerlink" title="面试题60：把二叉树打印成多行"></a>面试题60：把二叉树打印成多行</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题61：按之字形顺序打印二叉树"><a href="#面试题61：按之字形顺序打印二叉树" class="headerlink" title="面试题61：按之字形顺序打印二叉树"></a>面试题61：按之字形顺序打印二叉树</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题62：序列化二叉树"><a href="#面试题62：序列化二叉树" class="headerlink" title="面试题62：序列化二叉树"></a>面试题62：序列化二叉树</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题63：二叉搜索树的第k个结点"><a href="#面试题63：二叉搜索树的第k个结点" class="headerlink" title="面试题63：二叉搜索树的第k个结点"></a>面试题63：二叉搜索树的第k个结点</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题65：滑动窗口的最大值"><a href="#面试题65：滑动窗口的最大值" class="headerlink" title="面试题65：滑动窗口的最大值"></a>面试题65：滑动窗口的最大值</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找和排序"><a href="#查找和排序" class="headerlink" title="查找和排序"></a>查找和排序</h1><h3 id="面试题8：旋转数组中的最小数字"><a href="#面试题8：旋转数组中的最小数字" class="headerlink" title="面试题8：旋转数组中的最小数字"></a>面试题8：旋转数组中的最小数字</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h3 id="面试题9：斐波那契数列"><a href="#面试题9：斐波那契数列" class="headerlink" title="面试题9：斐波那契数列"></a>面试题9：斐波那契数列</h3><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39</p></blockquote><p>思路：第一种方法，简单递归。小数据量还OK，大一点的数据耗时就很久了，时间复杂度是O(2^n)。第二种方法，<strong>动态规划</strong>。求第n项，需要前n-1和n-2项来确定第n项的值。可以通过建立两个数不断记录第n-1和n-2项，直到第n项的时候就能够得到该题的解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fn = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> f0;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> f1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            fn = f1 + f0;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> result[n];</span><br><span class="line">        <span class="keyword">int</span> maxNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            answer = maxNum + minNum;</span><br><span class="line">            minNum = maxNum;<span class="comment">//用作记录</span></span><br><span class="line">            maxNum = answer;<span class="comment">//用作记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题31：连续子数组的最大和"><a href="#面试题31：连续子数组的最大和" class="headerlink" title="面试题31：连续子数组的最大和"></a>面试题31：连续子数组的最大和</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题34：丑数"><a href="#面试题34：丑数" class="headerlink" title="面试题34：丑数"></a>面试题34：丑数</h3><blockquote><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><p>思路：两种思路，第一种就是暴力法，不必多言；第二种是动态规划，后面的丑数一定是由前面的丑数乘以2、3或5得到。所以第n个丑数一定是由前n-1个数中的某3个丑数（分别记为i2、i3、i5）分别乘以2、3或者5得到的数中的最小数，i2，i3，i5有个特点，即分别乘以2、3、5得到的数一定含有比第n-1个丑数大（可利用反证法：否则第n-1个丑数就是它们当中的一个）最小丑数，即第n个丑数由ugly[i2] <em> 2、ugly[i3] </em> 3、ugly[i5] * 5中的最小数得出。让它们分别和第n个丑数比较，若和第n个丑数相等，则更新它们的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> []ugly = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">            ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> i2,i3,i5;</span><br><span class="line">            i2 = i3 = i5 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; index;i ++) &#123;</span><br><span class="line">                ugly[i] = Math.min(ugly[i2] * <span class="number">2</span>, Math.ugly(res[i3] * <span class="number">3</span>, ugly[i5] * <span class="number">5</span>));</span><br><span class="line">                <span class="keyword">if</span> (ugly[i] == ugly[i2] * <span class="number">2</span>) i2 ++;</span><br><span class="line">                <span class="keyword">if</span> (ugly[i] == ugly[i3] * <span class="number">3</span>) i3 ++;</span><br><span class="line">                <span class="keyword">if</span> (ugly[i] == ugly[i5] * <span class="number">5</span>) i5 ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ugly[index - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题45：圆圈中最后剩下的数字"><a href="#面试题45：圆圈中最后剩下的数字" class="headerlink" title="面试题45：圆圈中最后剩下的数字"></a>面试题45：圆圈中最后剩下的数字</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="回朔法"><a href="#回朔法" class="headerlink" title="回朔法"></a>回朔法</h1><h3 id="面试题66：矩阵中的路径"><a href="#面试题66：矩阵中的路径" class="headerlink" title="面试题66：矩阵中的路径"></a>面试题66：矩阵中的路径</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题67：机器人的运动范围"><a href="#面试题67：机器人的运动范围" class="headerlink" title="面试题67：机器人的运动范围"></a>面试题67：机器人的运动范围</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="细节实现题"><a href="#细节实现题" class="headerlink" title="细节实现题"></a>细节实现题</h1><h3 id="面试题10：二进制中1的个数"><a href="#面试题10：二进制中1的个数" class="headerlink" title="面试题10：二进制中1的个数"></a>面试题10：二进制中1的个数</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题11：数值的整数次方"><a href="#面试题11：数值的整数次方" class="headerlink" title="面试题11：数值的整数次方"></a>面试题11：数值的整数次方</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题20：顺时针打印矩阵"><a href="#面试题20：顺时针打印矩阵" class="headerlink" title="面试题20：顺时针打印矩阵"></a>面试题20：顺时针打印矩阵</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题41：和为s的两个数字VS和为s的连续正数序列"><a href="#面试题41：和为s的两个数字VS和为s的连续正数序列" class="headerlink" title="面试题41：和为s的两个数字VS和为s的连续正数序列"></a>面试题41：和为s的两个数字VS和为s的连续正数序列</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题43：n哥骰子的点数"><a href="#面试题43：n哥骰子的点数" class="headerlink" title="面试题43：n哥骰子的点数"></a>面试题43：n哥骰子的点数</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题44：扑克牌顺子"><a href="#面试题44：扑克牌顺子" class="headerlink" title="面试题44：扑克牌顺子"></a>面试题44：扑克牌顺子</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面试题46：求1-2-3-……-n"><a href="#面试题46：求1-2-3-……-n" class="headerlink" title="面试题46：求1+2+3+…….+n"></a>面试题46：求1+2+3+…….+n</h3><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><p>思路：  利用递归的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=n;</span><br><span class="line">        <span class="keyword">boolean</span> result=(n&gt;<span class="number">0</span>)&amp;&amp;((sum+=Sum_Solution(n-<span class="number">1</span>))&gt;<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题47：不用加减乘除做加法"><a href="#面试题47：不用加减乘除做加法" class="headerlink" title="面试题47：不用加减乘除做加法"></a>面试题47：不用加减乘除做加法</h3><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><p>思路：涉及JAVA的位运算。</p><p>&lt;&lt;      :     左移运算符，num &lt;&lt; 1,相当于num乘以2</p><p>>&gt;      :     右移运算符，num &gt;&gt; 1,相当于num除以2</p><p>加法的运算过程其实分为两步，第一步，相加各位的值；第二步，计算进位，并对第一步得出的值进行修改。</p><p>由此，二进制每位相加就是取异或的过程；每位相与在左移一位即进位操作；重复这两步，直至跳出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (num2!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = num1^num2;</span><br><span class="line">            num2 = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            num1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题64：数据流中的中位数"><a href="#面试题64：数据流中的中位数" class="headerlink" title="面试题64：数据流中的中位数"></a>面试题64：数据流中的中位数</h3><blockquote></blockquote><p>思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;线性表&quot;&gt;&lt;a href=&quot;#线性表&quot; class=&quot;headerlink&quot; title=&quot;线性表&quot;&gt;&lt;/a&gt;线性表&lt;/h1&gt;&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;
      
    
    </summary>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/categories/algorithm/"/>
    
    
      <category term="Java" scheme="https://seanxuu.github.io/tags/Java/"/>
    
      <category term="剑指offer" scheme="https://seanxuu.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>JVM学习笔记之内存模型与线程</title>
    <link href="https://seanxuu.github.io/archives/bfe2bfe1.html"/>
    <id>https://seanxuu.github.io/archives/bfe2bfe1.html</id>
    <published>2018-12-25T08:57:50.000Z</published>
    <updated>2018-12-25T08:57:50.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>内存模型（用一种Java内存模型来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果）<ul><li>主内存与工作内存<ul><li>主要目标：定义程序中各个变量（实例字段、静态字段、构成数组对象的元素，但不包括局部变量与方法参数）的访问规则</li><li>所有变量存储在主内存，每条线程有自己的工作内存<ul><li>工作内存保存了被该线程使用到的变量的主内存副本拷贝</li><li>线程对变量的所有操作都必须在工作内存中进行</li><li>不同的线程之间无法直接访问对方工作内存中的变量</li><li>线程间变量值的传递需要通过主内存来完成</li></ul></li></ul></li><li>内存间交互操作<ul><li>lock unlock read load use assign store write</li></ul></li><li>对于volatile型变量的特殊规则（最轻量级同步机制）<ul><li>对所有线程的可见性：</li><li>禁止指令重排序优化：</li></ul></li><li>对于long、double型变量的特殊规则<ul><li>允许虚拟机实现选择可以不保证64位数据类型的load、store、read、write这四个操作的原子性</li></ul></li><li>原子性、可见性、有序性</li><li>先行发生原则</li></ul></li><li><p>Java与线程</p><ul><li>线程的实现<ul><li>各个线程既可以共享进程资源，又可以独立调度</li><li>Thread类的所有关键方法都声明为Native（这个方法没有使用或无法使用平台无关的手段来实现）的</li><li>实现线程的方式<ul><li>使用内核线程实现<ul><li>内核线程是直接由操作系统内核支持的线程，由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上</li><li>轻量级进程：每个轻量级进程都由一个内核线程支持，是一个独立的调度单元<ul><li>局限性：进行系统调用，代价相对较高；消耗内核资源</li></ul></li></ul></li><li>使用用户线程实现<ul><li>一个线程不是内核线程，它就是用户线程（在用户态中完成各项操作，不需要内核的帮助）</li></ul></li><li>混合实现<ul><li>用户线程与轻量级进程的数量比：N:M</li></ul></li><li>Java线程的实现：不同操作系统具有不同的实现方式</li></ul></li></ul></li><li>线程调度：系统为线程分配处理器使用权的过程<ul><li>协同式<ul><li>执行时间由线程本身来控制</li><li>好处：实现简单</li><li>坏处：线程执行时间不可控</li></ul></li><li>抢占式（Java使用的线程调度方式）<ul><li>执行时间由系统分配</li></ul></li></ul></li><li><p>状态转换：五种状态</p><ul><li>新建 运行 无限期等待 限期等待 阻塞 结束</li></ul></li></ul></li></ul><p>参考资料：《深入理解java虚拟机》——周志明 著</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;内存模型（用一种Java内存模型来屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果）&lt;ul&gt;
&lt;li&gt;主内存与工作内存&lt;ul&gt;
&lt;li&gt;主要目标：定义程序中各个变量（实例字段、静态字段、构成数组对象的元素，但不包括
      
    
    </summary>
    
      <category term="JVM" scheme="https://seanxuu.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://seanxuu.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://seanxuu.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-136</title>
    <link href="https://seanxuu.github.io/archives/25a125af.html"/>
    <id>https://seanxuu.github.io/archives/25a125af.html</id>
    <published>2018-11-28T05:56:15.000Z</published>
    <updated>2018-11-28T05:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.length;i++)&#123;</span><br><span class="line">            result = result^nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-104</title>
    <link href="https://seanxuu.github.io/archives/e0821740.html"/>
    <id>https://seanxuu.github.io/archives/e0821740.html</id>
    <published>2018-11-28T05:56:03.000Z</published>
    <updated>2018-11-28T05:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> leftDepth = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightDepth = maxDepth(root.right);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> bigger = Math.max(leftDepth, rightDepth);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bigger+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-27</title>
    <link href="https://seanxuu.github.io/archives/eddde878.html"/>
    <id>https://seanxuu.github.io/archives/eddde878.html</id>
    <published>2018-11-27T06:16:09.000Z</published>
    <updated>2018-11-27T06:16:09.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历数组，用数组最后元素替换相同元素，并缩短数组长度</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val) &#123;</span><br><span class="line">                nums[i]=nums[n-<span class="number">1</span>];</span><br><span class="line">                n--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-94</title>
    <link href="https://seanxuu.github.io/archives/97206009.html"/>
    <id>https://seanxuu.github.io/archives/97206009.html</id>
    <published>2018-11-27T06:16:09.000Z</published>
    <updated>2018-11-27T06:16:09.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    helper(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    helper(root.left,res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    helper(root.right,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解-26</title>
    <link href="https://seanxuu.github.io/archives/9adad8ee.html"/>
    <id>https://seanxuu.github.io/archives/9adad8ee.html</id>
    <published>2018-11-27T06:15:55.000Z</published>
    <updated>2018-11-27T06:15:55.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] != nums[j])&#123;</span><br><span class="line">                    nums[j+<span class="number">1</span>]=nums[i];</span><br><span class="line">                    sum++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Win10环境下完美卸载MySQL</title>
    <link href="https://seanxuu.github.io/archives/59a4b6ee.html"/>
    <id>https://seanxuu.github.io/archives/59a4b6ee.html</id>
    <published>2018-10-21T02:04:51.000Z</published>
    <updated>2018-10-21T02:04:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    最近在使用MySQL的时候，遇到一个很棘手的问题——MySQL的服务总是开启不了。在网上搜索了多种办法，依然没法解决。所以我想干脆就重装MySQL算了。由于之前听说MySQL容易卸载不干净，所以我就想了一下之前完美卸载multisim的方法和步骤，照葫芦画瓢。最后还真的成功了！具体方法如下：</p><h3 id="1-停止MySQL服务。"><a href="#1-停止MySQL服务。" class="headerlink" title="1.  停止MySQL服务。"></a>1.  停止MySQL服务。</h3><p>   任务管理器→服务→找到MySQL服务，停止掉。</p><h3 id="2-卸载MySQL-server。"><a href="#2-卸载MySQL-server。" class="headerlink" title="2.  卸载MySQL server。"></a>2.  卸载MySQL server。</h3><p>   在控制面板中卸载。</p><h3 id="3-将MySQL安装目录下的MySQL文件夹删除。"><a href="#3-将MySQL安装目录下的MySQL文件夹删除。" class="headerlink" title="3.  将MySQL安装目录下的MySQL文件夹删除。"></a>3.  将MySQL安装目录下的MySQL文件夹删除。</h3><p>   如果删除不掉，就利用文件粉碎器粉碎。</p><p>   打开注册表，分别找到以下文件夹,删除（如果没有相应的文件夹，就忽略掉）</p><p>   <em>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL</em></p><p>   <em>HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL</em></p><p>   <em>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL**</em></p><h3 id="4-删除C-ProgramData-MySQL-文件夹"><a href="#4-删除C-ProgramData-MySQL-文件夹" class="headerlink" title="4.  删除C:\ProgramData\MySQL 文件夹"></a>4.  删除C:\ProgramData\MySQL 文件夹</h3><p>注意这个文件夹默认是隐藏的。</p><h3 id="5-为确保万无一失，需要再检查MySQL服务是否存在，若存在便利用在cmd中输入“sc-delete-xxxxx”删除服务（xxxxx是你要删除的服务名）。"><a href="#5-为确保万无一失，需要再检查MySQL服务是否存在，若存在便利用在cmd中输入“sc-delete-xxxxx”删除服务（xxxxx是你要删除的服务名）。" class="headerlink" title="5.  为确保万无一失，需要再检查MySQL服务是否存在，若存在便利用在cmd中输入“sc delete xxxxx”删除服务（xxxxx是你要删除的服务名）。"></a>5.  为确保万无一失，需要再检查MySQL服务是否存在，若存在便利用在cmd中输入“sc delete xxxxx”删除服务（xxxxx是你要删除的服务名）。</h3><h3 id="6-最后便可以重装MySQL了。"><a href="#6-最后便可以重装MySQL了。" class="headerlink" title="6. 最后便可以重装MySQL了。"></a>6. 最后便可以重装MySQL了。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    最近在使用MySQL的时候，遇到一个很棘手的问题——MySQL的服务总是开启不了。在网上搜索了多种办法，依然没法解决。所以我想干脆就重装MySQL算了。由于之前听说MySQL容易卸载不干净，所以我就想了一下之前完美卸载multisim的方法和步骤，照葫芦画瓢。最后
      
    
    </summary>
    
      <category term="MySQL" scheme="https://seanxuu.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://seanxuu.github.io/tags/MySQL/"/>
    
      <category term="完美卸载" scheme="https://seanxuu.github.io/tags/%E5%AE%8C%E7%BE%8E%E5%8D%B8%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解 771. Jewels and Stones</title>
    <link href="https://seanxuu.github.io/archives/a83ed523.html"/>
    <id>https://seanxuu.github.io/archives/a83ed523.html</id>
    <published>2018-05-23T15:33:02.000Z</published>
    <updated>2018-05-23T15:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>You’re given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.  Each character in <code>S</code>is a type of stone you have.  You want to know how many of the stones you have are also jewels.</p><p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>&quot;a&quot;</code> is considered a different type of stone from <code>&quot;A&quot;</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li><p><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</p></li><li><p>The characters in <code>J</code> are distinct.</p><hr><p>Solution:</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> [] s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">100</span>];<span class="comment">//新建一个字符数组来存储Jewels中的每一个元素</span></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; J.length(); i++)&#123;<span class="comment">//将Jewels中的元素取出，放入字符数组s中</span></span><br><span class="line">         s[i] = J.charAt(i); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; S.length(); j++)&#123;<span class="comment">//大循环：对Stone进行遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; J.length(); k++)&#123;<span class="comment">//小循环：用s中的每一个元素和Stone中的元素比较</span></span><br><span class="line">                <span class="keyword">if</span> (s[k] == S.charAt(j))</span><br><span class="line">                    counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> counter;  <span class="comment">//返回计数器</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反思：</span></span><br><span class="line"><span class="comment">1.大小循环这里一开始没有想明白，导致遍历比较时候总是出错。</span></span><br><span class="line"><span class="comment">2.没能充分理解“字符串是对象”</span></span><br><span class="line"><span class="comment">3.对char 和 String 的区别不是很清楚</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;You’re given strings &lt;code&gt;J&lt;/code&gt; representing the types of stones that are jewels, and &lt;code&gt;S&lt;/code&gt; representing the stones you have
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解 1.Two Sum</title>
    <link href="https://seanxuu.github.io/archives/3757d865.html"/>
    <id>https://seanxuu.github.io/archives/3757d865.html</id>
    <published>2018-05-23T15:13:54.000Z</published>
    <updated>2018-05-23T15:13:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong>exactly</strong> one solution.</p><p><strong>Example:</strong></p><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p><hr><p>Solution:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> [] result = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    result[<span class="number">0</span>]=i;</span><br><span class="line">                    result[<span class="number">1</span>]=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">反思：</span></span><br><span class="line"><span class="comment">1.数组掌握不牢靠</span></span><br><span class="line"><span class="comment">2.对于常见错误不能很好调试</span></span><br><span class="line"><span class="comment">3.数组的赋值方法应该彻底了解</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Given an array of integers, return &lt;strong&gt;indices&lt;/strong&gt; of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may
      
    
    </summary>
    
      <category term="leetcode" scheme="https://seanxuu.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://seanxuu.github.io/tags/leetcode/"/>
    
      <category term="algorithm" scheme="https://seanxuu.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>关于当下自我状况的思考</title>
    <link href="https://seanxuu.github.io/archives/e182c17d.html"/>
    <id>https://seanxuu.github.io/archives/e182c17d.html</id>
    <published>2018-05-05T01:47:14.000Z</published>
    <updated>2018-05-05T01:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h2><p>​    在大学将近三年的学习中，我学过的科目越来越多，难度也依次加大，但是自己的学习方法好像没有特别大的改进，所以效率并不算太高，学习的时候没有了高中时候的那种目标感，并不清楚自己学习这些知识的用处是什么。难道仅仅是为了毕业？不，这不是我想要的！我不想白白把自己的时间荒废在一些无趣的事情上面。所以我开始想了一想我现在的处境以及面临的问题。</p><p>​    虽然我的专业名称是生物医学工程，但是仿佛应该叫做生物医学电子信息工程，因为大多数时候我所接受的教育都在告诉我如何通过电子信息工程方法去解决医学问题。这就让我产生了<strong>第一个疑惑：电子工程里的各种思维方法能不能支撑我在这个专业里走的更远？</strong> <strong>我的第二个疑惑其实很简单：电子信息工程这个大的框架下还有许多小的方向，那么我是不是也应该在课下学习更多不同的学科知识，拓宽自己的眼界？</strong> </p><h2 id="关于这些问题的一些思考"><a href="#关于这些问题的一些思考" class="headerlink" title="关于这些问题的一些思考"></a>关于这些问题的一些思考</h2><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><p>​    我所理解到的工科思维仅仅停留在：用趁手的榔头敲不同型号的钉子，而不用过多的考虑敲这颗钉子有什么用。事实上，我们好像也都是这么做的。许多老师在上课的时候，都会推荐两套教材，一套偏重理论和数学推导，一套偏重实际应用。可是，不知道是自己的数学底子太弱的缘故还是其他什么原因，我并不能权衡好这二者的关系。经常出现的一种情况就是：沉迷于推导公式无法自拔，以至于公式推完了，却忘记为什么要推导公式了。这一点在《信号与系统》这门课中尤其明显。我花了大量的时间去了解傅里叶的思想以及傅里叶变换、快速傅里叶变换、拉普拉斯变换、Z变换的推导方法，然而却对于为什么要去推公式没有丝毫印象了。最后的结果当然是“不识庐山真面目”，耗费了心力却一无所得。与之对立的便是，只晓得应用，而完全不愿去考虑其内部原理。我对于机器学习的相关理论基本都是这样的态度，所以在应用中经常出现各种我自己无法解释的错误。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>​    其实我也明白，找到平衡的点是解决这个问题的关键。但是，在学习的过程中，好像并没有谁来指引我们那个点在哪里。人们总是模糊的说：“既要掌握这个，又要掌握那个”。这种笼统的说法并不能使我信服。天资愚笨的我，只好花更多的时间去“两手抓，两手都要硬”了。</p><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><p>​    说起来，我们专业开的选修课也已经很多了：与计算机相关的数据库、C++、计算机网络、数据结构与算法、操作系统还有数据挖掘，与电子电路相关的：电磁场与电磁波、模拟电路、数字电路、数字信号处理、数字图像处理、随机信号分析、复变函数、信号与系统、电路分析、医学仪器原理、微处理器系统结构与嵌入式设计、信息论，还有一些基础技能课和生物医学导论课：数值分析、数学实验、生理学、解剖学、医学成像原理。说了这么多课程，我只想说明，学的东西真的很杂乱，而且学完之后内心没有真正接纳它们，所以很快这其中的大部分内容我都还给老师了。我不太清楚这是不是一种对生命的浪费，又或者是他们口中的“为了将来找份好工作，拥有好的生活”。但事实上，我并不能欺骗自己的内心。我确确实实迷失了，我不清楚我的“将来”在哪里。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>​    我想先去人多的地方看看，去见见世面，观察当下社会中他人的生活是怎样的。事实上，我一直是这么做的。我自己的生活方式便是结合了我眼中其他的我认为好的生活方式，并且让自己过得尽量满足。有了模板，我才有机会更好地修正自己的运动轨迹。我从来不觉得人生道路是可以被规划、可以被模仿的。它永远只能被执行并修正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题的出现&quot;&gt;&lt;a href=&quot;#问题的出现&quot; class=&quot;headerlink&quot; title=&quot;问题的出现&quot;&gt;&lt;/a&gt;问题的出现&lt;/h2&gt;&lt;p&gt;​    在大学将近三年的学习中，我学过的科目越来越多，难度也依次加大，但是自己的学习方法好像没有特别大的改进，所以
      
    
    </summary>
    
      <category term="随想" scheme="https://seanxuu.github.io/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="学习" scheme="https://seanxuu.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
